package com.sephora.services.common.availabilityhub.client;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;

import lombok.extern.log4j.Log4j2;

import java.io.BufferedReader;
import java.io.StringReader;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Base64;
import java.util.Date;
import java.util.concurrent.TimeUnit;

import javax.annotation.PostConstruct;

@Log4j2
@Component
@ConditionalOnProperty(prefix = "availabilityhub.client.jwttoken", value = "privateKeyId")
@Qualifier("availailityHubTokenGenerator")
public class JWTTokenGenerator {
	private static volatile String jwtToken = null;
	
	@Value(value = "${availabilityhub.client.jwttoken.privateKeyId}")
	private String privateKeyId;

	@Value(value = "${availabilityhub.client.jwttoken.issuer}")
	private String issuer;

	@Value(value = "${availabilityhub.client.jwttoken.audience}")
	private String audience;

	@Value(value = "${availabilityhub.client.jwttoken.privateKey}")
	private String privateKey;
	
	@Value(value = "${availabilityhub.client.jwttoken.timeToLive}")
	private String timeToLive;
	
	/**
	 * To get the token.
	 * This method will return globally stored  CURRENT_TOKEN 
	 * call generateToken() if the token is null and return the same.
	 * 
	 * @return
	 */
	public String getToken() {
		if(jwtToken == null) {
			jwtToken = generateToken(null);
		}
		return jwtToken;
	}

	/**
	 * This method will generate JWT token
	 * 
	 * @return
	 */
	public synchronized String generateToken(String previousJWTTOken) {
		
		// if jwtToken is generated for the first time or JWTToken got regenerated by other thread while this thread was
		// waiting to enter this method 
		if ( jwtToken != null && false  == jwtToken.equals(previousJWTTOken) ) {
			log.error("JWTToken got re-generated by another thread. No need to generate again");
			return jwtToken;
		}
		
		try {
			RSAPrivateKey key = (RSAPrivateKey) getPrivateKey(privateKey);
			Algorithm algorithm = Algorithm.RSA256(null, key);

			jwtToken = String.join(
					" ",
					"Bearer",
					JWT.create()
							.withKeyId(privateKeyId)
							.withIssuer(issuer)
							.withSubject(issuer)
							.withAudience(audience)
							.withIssuedAt(asDate(LocalDateTime.now()))
							.withExpiresAt(asDate(LocalDateTime.now().plusMinutes(Long.parseLong(timeToLive) + 1)))
							.sign(algorithm)
			);
			
			log.info("Succsfully generated JWTToken");


		} catch (Exception e) {
			log.error("Exception occured while generating jwt token", e);
		}
		
		return jwtToken;
	}
	
	/**
	 * To convert LocalDateTime to java.util.Date
	 * 
	 * @param dateTime
	 * @return
	 */
	private Date asDate(LocalDateTime dateTime) {
		return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());
	}

	/**
	 * To make java.security.PrivateKey from string
	 * @param privateKey
	 * @return
	 * @throws Exception
	 */
	private PrivateKey getPrivateKey(String privateKey) throws Exception {
		// Read in the key into a String
		StringBuilder pkcs8Lines = new StringBuilder();
		BufferedReader rdr = new BufferedReader(new StringReader(privateKey));
		String line;
		while ((line = rdr.readLine()) != null) {
			pkcs8Lines.append(line);
		}

		// Remove the "BEGIN" and "END" lines, as well as any whitespace
		String pkcs8Pem = pkcs8Lines.toString();
		pkcs8Pem = pkcs8Pem.replace("-----BEGIN PRIVATE KEY-----", "");
		pkcs8Pem = pkcs8Pem.replace("-----END PRIVATE KEY-----", "");
		pkcs8Pem = pkcs8Pem.replaceAll("\\\\n", "");

		// Base64 decode the result
		byte[] pkcs8EncodedBytes = Base64.getDecoder().decode(pkcs8Pem);

		// extract the private key
		PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(pkcs8EncodedBytes);
		KeyFactory kf = KeyFactory.getInstance("RSA");
		return kf.generatePrivate(keySpec);

	}
	
	@PostConstruct
	public void init() {
		generateToken(null);
	}
}
